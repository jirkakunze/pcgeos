/********************************************************************
 *
 * PROJECT:          ShiSen-Sho Game for PC/Geos
 *
 * DESCRIPTION:	     a japanese game similar to mahjongg
 *
 * FILE:             board.goc
 *
 * REMARK:           Licensed under the Apache License, Version 2.0
 *                   (the "License"); you may not use this file
 *                   except in compliance with the License.
 *                   You may obtain a copy of the License at
 *
 *                       http://www.apache.org/licenses/LICENSE-2.0
 *
 *                   Unless required by applicable law or agreed to
 *                   in writing, software distributed under the
 *                   License is distributed on an "AS IS" BASIS,
 *                   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 *                   either express or implied. See the License for the
 *                   specific language governing permissions and
 *                   limitations under the License.
 *
 * REVISION HISTORY:
 *      Date      Name      Description
 *      ----      ----      -----------
 *      08.08.00  JK        initial version
 *      14.11.25  JK        clean up
 *
 ********************************************************************/
@define _SHISEN_BOARD_GOC_

@include "shisen.goh"
@include "Art/craks.goh"
@include "Art/dots.goh"
@include "Art/bamboo.goh"
@include "Art/season.goh"
@include "Art/dragons.goh"
@include "Art/direc.goh"
@include "Art/flowers.goh"

@extern chunk NoMovesLeft;
@extern chunk BoardCleared;

@classdecl ShisenBoardClass;

/***********************************************************************
 *              MSG_VIS_DRAW for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Draws the entire game board including all tiles, 
 *              highlights selected tiles, and draws any active path
 *              between tiles.
 *  
 * PARAMETERS:  DrawFlags drawFlags  – flags controlling the drawing behavior
 *              GStateHandle gstate  – graphics state used for drawing
 *
 * STRATEGY:    1. Fill background with green color.
 *              2. Iterate over each position in the playfield:
 *                   - If a tile exists, lock it, load its graphics string,
 *                     draw it, and unlock it.
 *                   - If the tile is selected, draw a highlight rectangle.
 *                   - If the position is empty, draw a blank rectangle.
 *              3. Draw lines connecting tiles based on the history buffer.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 +      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_VIS_DRAW
{
  int     x, y, num;
  byte*   data;
  word*   last;
  GStateHandle  string;
  optr    tileList[] =
        {@Crak1, @Crak2, @Crak3, @Crak4, @Crak5, /* defined in craks.goh */
         @Crak6, @Crak7, @Crak8, @Crak9,
         @Dot1, @Dot2, @Dot3, @Dot4, @Dot5,      /* defined in dots.goh  */
         @Dot6, @Dot7, @Dot8, @Dot9,
         @Bamboo1, @Bamboo2, @Bamboo3, @Bamboo4, @Bamboo5,
         @Bamboo6, @Bamboo7, @Bamboo8, @Bamboo9,
         @Winter, @Autumn, @Summer, @Spring,
         @DragonC, @DragonF, @DragonP,
         @North, @South, @West, @East,
         @Bamboo, @Plum, @Orchid, @Mum};

  GrSetAreaColor(gstate, CF_INDEX, C_GREEN, 0, 0);

  for (x = 0; x <= pself->SBI_fieldWidth; x++)
  {
    for (y = 0; y <= pself->SBI_fieldHeight; y++)
    {
      if (pself->SBI_playField[x][y] != EMPTY)
      {
        /* Lock the tile, load its graphics string, draw it, then unlock */
        MemLock(OptrToHandle(tileList[pself->SBI_playField[x][y]]));
        data = LMemDeref(tileList[pself->SBI_playField[x][y]]);
        string = GrLoadGString(PtrToSegment(data), GST_PTR, PtrToOffset(data));
        GrDrawGString(gstate, string, x * TILE_WIDTH, y * TILE_HEIGHT, 0, last);
        GrDestroyGString(string, NULL, GSKT_LEAVE_DATA);
        MemUnlock(OptrToHandle(tileList[pself->SBI_playField[x][y]]));

        /* Highlight tile if selected */
        if ((pself->SBI_selectX1 == x && pself->SBI_selectY1 == y) ||
            (pself->SBI_selectX2 == x && pself->SBI_selectY2 == y))
        {
          GrSaveState(gstate);
          GrSetMixMode(gstate, MM_INVERT);
          GrFillRect(gstate, x * TILE_WIDTH + 4, y * TILE_HEIGHT + 1,
                             x * TILE_WIDTH + TILE_WIDTH - 1,
                             y * TILE_HEIGHT + TILE_HEIGHT - 4);
          GrRestoreState(gstate);
        }
      }
      else
      {
        /* Draw empty rectangle for positions without a tile */
        GrFillRect(gstate, x * TILE_WIDTH, y * TILE_HEIGHT,
                           x * TILE_WIDTH + TILE_WIDTH,
                           y * TILE_HEIGHT + TILE_HEIGHT);
      }
    }
  }

  /* Draw path between tiles if present */
  GrSetLineWidth(gstate, MakeWWFixed(3));
  GrSetLineColor(gstate, CF_INDEX, C_RED, 0, 0);
  for (num = 0; num < 3; num++)
  {
    if (pself->SBI_historyX[num+1] || pself->SBI_historyY[num+1])
    {
      GrDrawLine(gstate,
                 pself->SBI_historyX[num] * TILE_WIDTH + TILE_WIDTH / 2,
                 pself->SBI_historyY[num] * TILE_HEIGHT + TILE_HEIGHT / 2,
                 pself->SBI_historyX[num+1] * TILE_WIDTH + TILE_WIDTH / 2,
                 pself->SBI_historyY[num+1] * TILE_HEIGHT + TILE_HEIGHT / 2);
    }
  }
}

/***********************************************************************
 *              MSG_META_START_SELECT for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Determines which tile was clicked, updates the current
 *              selection state, and processes single or double tile
 *              selection. If two different tiles are selected, the method
 *              tests the connection path and schedules a board update.
 *  
 * PARAMETERS:  MouseReturnParams *retVal  – return flags for mouse handling
 *              word xPosition             – mouse X position in pixels
 *              word yPosition             – mouse Y position in pixels
 *              word inputState            – current mouse/keyboard state
 *
 * STRATEGY:    1. Retrieve the current selection.
 *              2. Convert mouse position into playfield coordinates.
 *              3. If a tile exists at that location:
 *                   - If no tile was previously selected, set as first selection.
 *                   - Else if only one tile was selected:
 *                       * If the same tile is clicked again, clear selection.
 *                       * Otherwise select the second tile, test the path,
 *                         and schedule a delayed board update.
 *              4. Redraw the entire board.
 *              5. Mark the mouse event as processed.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_META_START_SELECT
{
  int      x1, y1, x2, y2;
  int      selX, selY;
  word     timerId;

  /* get current selected positions */
  @call self::MSG_SHISEN_GET_SELECTION(&x1, &y1, &x2, &y2);

  /* calculate playfield position of mouse event */
  selX = xPosition / TILE_WIDTH;
  selY = yPosition / TILE_HEIGHT;

  /* is mouse event inside a valid tile? */
  if (pself->SBI_playField[selX][selY] != EMPTY)
  {
    /* is this the first selection? */
    if (x1 == 0 && y1 == 0)
    {
      @call self::MSG_SHISEN_SET_SELECTION(selX, selY, 0, 0);
    }
    else
    {
      /* is this the second selection? */
      if (x2 == 0 && y2 == 0)
      {
        /* clicking the already selected tile clears the selection */
        if (selX == x1 && selY == y1)
        {
          @call self::MSG_SHISEN_SET_SELECTION(0, 0, 0, 0);
        }
        else
        {
          /* two different tiles selected → test path and update board */
          @call self::MSG_SHISEN_SET_SELECTION(x1, y1, selX, selY);
          @call self::MSG_SHISEN_TEST_PATH(x1, y1, selX, selY);
          pself->SBI_timerHan =
              TimerStart(TIMER_EVENT_ONE_SHOT,
                         oself, 60, MSG_SHISEN_UPDATE_BOARD,
                         60, &timerId);
        }
      }
    }
  }

  @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
  retVal->flags = MRF_PROCESSED | MRF_CLEAR_POINTER_IMAGE;
}

/***********************************************************************
 *              MSG_SHISEN_CLEAR_HISTORY for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Clears all entries in the path-history buffer.  
 *              This removes any stored coordinates used for drawing
 *              connection paths between tiles.
 *  
 * PARAMETERS:  void
 *
 * STRATEGY:    Iterate over the history arrays and clear each entry.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_CLEAR_HISTORY
{
  int i;

  for (i = 0; i < 4; i++)
  {
    pself->SBI_historyX[i] = 0;
    pself->SBI_historyY[i] = 0;
  }
}

/***********************************************************************
 *              MSG_SHISEN_SET_SELECTION for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Sets the coordinates of the currently selected tiles.
 *              The values (x1, y1) identify the first selected tile,
 *              and (x2, y2) identify the second selected tile.
 *  
 * PARAMETERS:  char x1  – X-coordinate of first selected tile
 *              char y1  – Y-coordinate of first selected tile
 *              char x2  – X-coordinate of second selected tile
 *              char y2  – Y-coordinate of second selected tile
 *
 * STRATEGY:    Store all four selection coordinates directly in the
 *              instance variables dedicated to tile selection.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_SET_SELECTION
{
  pself->SBI_selectX1 = x1;
  pself->SBI_selectY1 = y1;
  pself->SBI_selectX2 = x2;
  pself->SBI_selectY2 = y2;
}

/***********************************************************************
 *              MSG_SHISEN_GET_SELECTION for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Retrieves the coordinates of the currently selected tiles.
 *              The method returns the positions stored as the first and
 *              second selections.
 *  
 * PARAMETERS:  int* x1  – receives X-coordinate of first selected tile
 *              int* y1  – receives Y-coordinate of first selected tile
 *              int* x2  – receives X-coordinate of second selected tile
 *              int* y2  – receives Y-coordinate of second selected tile
 *
 * STRATEGY:    Copy the internal selection coordinates into the
 *              caller-provided output variables.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_GET_SELECTION
{
  *x1 = pself->SBI_selectX1;
  *y1 = pself->SBI_selectY1;
  *x2 = pself->SBI_selectX2;
  *y2 = pself->SBI_selectY2;
}


/***********************************************************************
 *              MSG_SHISEN_GET_HINT for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Searches for a valid move on the board.  
 *              If one is found, the method highlights the two tiles
 *              involved in the move and schedules a delayed board update.
 *  
 * PARAMETERS:  void
 *
 * STRATEGY:    1. Call MSG_SHISEN_GET_MOVE to find any valid pair of tiles
 *                 that can be matched.
 *              2. If such a move exists:
 *                   - Select both tiles.
 *                   - Redraw the board.
 *                   - Schedule a timed call to update the board.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_GET_HINT
{
  int      x1, y1, x2, y2;
  word     timerId;

  /* get position for an allowed move */
  @call self::MSG_SHISEN_GET_MOVE(&x1, &y1, &x2, &y2);

  if (x1 && y1 && x2 && y2)
  {
    @call self::MSG_SHISEN_SET_SELECTION(x1, y1, x2, y2);
    @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();

    /* update playfield after 1 second */
    pself->SBI_timerHan = TimerStart(TIMER_EVENT_ONE_SHOT,
                   oself, 60, MSG_SHISEN_UPDATE_BOARD, 60, &timerId);
  }
}


/***********************************************************************
 *              MSG_SHISEN_GET_MOVE for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Searches the playfield for any valid move.  
 *              If two tiles can legally be connected, their coordinates
 *              are returned as the start and end positions.
 *  
 * PARAMETERS:  int* startX  – receives X-coordinate of first tile
 *              int* startY  – receives Y-coordinate of first tile
 *              int* endX    – receives X-coordinate of second tile
 *              int* endY    – receives Y-coordinate of second tile
 *
 * STRATEGY:    1. Reset selection and history.
 *              2. Scan the board from top-left to bottom-right to find
 *                 the first non-empty tile.
 *              3. For each such tile, scan backward from bottom-right
 *                 to top-left to find another non-empty tile.
 *              4. For each tile pair, check whether a valid path exists.
 *              5. On success: clear history, return coordinates, exit.
 *              6. If no valid move is found, return zeroed coordinates.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_GET_MOVE
{
  int x1, y1, x2, y2;

  /* clear selections and history buffer */
  @call self::MSG_SHISEN_SET_SELECTION(0, 0, 0, 0);
  @call self::MSG_SHISEN_CLEAR_HISTORY();

  /* find the first allowed game tile */
  for (x1 = 1; x1 < pself->SBI_fieldWidth; x1++)
  {
    for (y1 = 1; y1 < pself->SBI_fieldHeight; y1++)
    {
      if (pself->SBI_playField[x1][y1] != EMPTY)
      {
        /* search for a matching second tile */
        for (x2 = pself->SBI_fieldWidth - 1; x2 > 0; x2--)
        {
          for (y2 = 1; y2 < pself->SBI_fieldHeight; y2++)
          {
            if ((x1 != x2 || y1 != y2) &&
                pself->SBI_playField[x2][y2] != EMPTY)
            {
              /* test if a path exists between the two tiles */
              if (@call self::MSG_SHISEN_TEST_PATH(x1, y1, x2, y2))
              {
                @call self::MSG_SHISEN_CLEAR_HISTORY();

                /* save move positions and return */
                *startX = x1;
                *startY = y1;
                *endX   = x2;
                *endY   = y2;

                return;
              }
            }
          }
        }
      }
    }
  }

  /* no valid move found */
  *startX = 0;
  *startY = 0;
  *endX   = 0;
  *endY   = 0;
}

/***********************************************************************
 *              MSG_SHISEN_NEW_BOARD for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Creates a new playfield with the given width and height.
 *              Initializes the board, clears all selection data, and
 *              assigns random tile pairs to all valid positions.
 *
 * PARAMETERS:  int width   – width of the new playfield
 *              int height  – height of the new playfield
 *
 * STRATEGY:    1. Store board dimensions.
 *              2. Reset selection and history.
 *              3. Mark entire playfield as EMPTY.
 *              4. Resize visual object according to board size.
 *              5. Compute number of tile pairs and maximum tile index
 *                 (based on board size selection).
 *              6. Randomly assign tiles in pairs so that every tile in
 *                 the game occurs exactly twice.
 *              7. Request full redraw of the game board.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_NEW_BOARD
{
  int   x1, y1;
  int   tile = 0;
  word  numTiles;
  word  maxTileIndex;

  /* save board dimensions */
  pself->SBI_fieldWidth  = width;
  pself->SBI_fieldHeight = height;

  /* clear selection and history data */
  @call self::MSG_SHISEN_SET_SELECTION(0, 0, 0, 0);
  @call self::MSG_SHISEN_CLEAR_HISTORY();

  /* mark all field entries as EMPTY */
  for (x1 = 0; x1 <= pself->SBI_fieldWidth; x1++)
    for (y1 = 0; y1 <= pself->SBI_fieldHeight; y1++)
      pself->SBI_playField[x1][y1] = EMPTY;

  /* set object size in pixels */
  @call self::MSG_VIS_SET_SIZE(TILE_WIDTH  + TILE_WIDTH  * width,
                               TILE_HEIGHT + TILE_HEIGHT * height);

  /* calculate number of tile pairs and max tile index for this board size */
  numTiles     = (width - 1) * (height - 1) / 2;
  maxTileIndex = @call ShisenBoardSizeList::MSG_GEN_ITEM_GROUP_GET_SELECTION();

  /* fill playfield with random tile pairs */
  while (numTiles--)
  {
    /* -------------------------- First tile -------------------------- */
    x1 = GameRandom(width - 1) + 1;
    y1 = GameRandom(height - 1) + 1;

    while (pself->SBI_playField[x1][y1] != EMPTY)
    {
      x1++;
      if (x1 == width)
      {
        x1 = 1;
        y1++;
        if (y1 == height) y1 = 1;
      }
    }
    pself->SBI_playField[x1][y1] = tile;

    /* ------------------------- Second tile -------------------------- */
    x1 = GameRandom(width - 1) + 1;
    y1 = GameRandom(height - 1) + 1;

    while (pself->SBI_playField[x1][y1] != EMPTY)
    {
      x1++;
      if (x1 == width)
      {
        x1 = 1;
        y1++;
        if (y1 == height) y1 = 1;
      }
    }
    pself->SBI_playField[x1][y1] = tile;

    /* next tile index, wrap around if needed */
    tile++;
    if (tile == maxTileIndex)
      tile = 0;
  }

  /* trigger redraw of the playfield */
  @send self::MSG_VIS_REDRAW_ENTIRE_OBJECT();
}

/***********************************************************************
 *              MSG_SHISEN_TEST_PATH for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Tests whether a valid connection path exists between two
 *              tiles located at (startX, startY) and (endX, endY).  
 *              A path is valid if the two tiles have the same value and
 *              can be connected by zero, one, or two orthogonal bends
 *              without crossing other tiles.
 *  
 * PARAMETERS:  int startX  – X-coordinate of the first tile
 *              int startY  – Y-coordinate of the first tile
 *              int endX    – X-coordinate of the second tile
 *              int endY    – Y-coordinate of the second tile
 *
 * STRATEGY:
 *              1. Clear any previously stored path.
 *              2. Ensure both tiles have the same value.
 *              3. Attempt direct two-segment paths (MSG_SHISEN_FIND_2WAY_PATH).
 *              4. If not found, search outward from the start tile in
 *                 all four directions, scanning empty cells and testing
 *                 each as a potential turning point.
 *              5. If a path is found, shift history data and store the
 *                 start tile as the path's origin.
 *
 * RETURN:      Boolean – TRUE if a valid path exists, FALSE otherwise.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_TEST_PATH
{
  sword dx[4] = {-1, 0, 1, 0};
  sword dy[4] = { 0,-1, 0, 1};
  word  i;
  Boolean ret = FALSE;

  @call self::MSG_SHISEN_CLEAR_HISTORY();

  /* tiles must match to form a valid pair */
  if (pself->SBI_playField[startX][startY] ==
      pself->SBI_playField[endX][endY])
  {
    /* try direct or one-turn connections */
    if (@call self::MSG_SHISEN_FIND_2WAY_PATH(startX, startY, endX, endY))
    {
      ret = TRUE;
    }
    else
    {
      /* explore in 4 directions to find potential turning points */
      for (i = 0; i < 4; i++)
      {
        sword newx = startX + dx[i];
        sword newy = startY + dy[i];

        while (pself->SBI_playField[newx][newy] == EMPTY &&
               newx >= 0 && newx <= pself->SBI_fieldWidth &&
               newy >= 0 && newy <= pself->SBI_fieldHeight &&
               ret == FALSE)
        {
          if (@call self::MSG_SHISEN_FIND_2WAY_PATH(newx, newy, endX, endY))
          {
            ret = TRUE;
          }

          newx += dx[i];
          newy += dy[i];
        }
      }

      /* if path found, rotate and insert new history entries */
      if (ret)
      {
        pself->SBI_historyX[3] = pself->SBI_historyX[2];
        pself->SBI_historyY[3] = pself->SBI_historyY[2];
        pself->SBI_historyX[2] = pself->SBI_historyX[1];
        pself->SBI_historyY[2] = pself->SBI_historyY[1];
        pself->SBI_historyX[1] = pself->SBI_historyX[0];
        pself->SBI_historyY[1] = pself->SBI_historyY[0];
        pself->SBI_historyX[0] = startX;
        pself->SBI_historyY[0] = startY;
      }
    }
  }

  return ret;
}

/***********************************************************************
 *              MSG_SHISEN_FIND_2WAY_PATH for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Attempts to find a valid connection path between two tiles
 *              using at most two orthogonal segments (i.e., up to one bend).
 *              A path is valid only if all intermediate cells are EMPTY.
 *  
 * PARAMETERS:  int startX  – X-coordinate of starting tile
 *              int startY  – Y-coordinate of starting tile
 *              int endX    – X-coordinate of target tile
 *              int endY    – Y-coordinate of target tile
 *
 * STRATEGY:
 *              1. First test a direct one-segment path using
 *                 MSG_SHISEN_FIND_1WAY_PATH.  
 *                 If successful, the path is simply start → end.
 *
 *              2. If no direct path exists and the tiles are not aligned
 *                 horizontally or vertically, try two possible L-shaped paths:
 *
 *                    a)  start → (endX, startY) → end
 *                    b)  start → (startX, endY) → end
 *
 *                 These turning points must be EMPTY, and both straight
 *                 segments must be passable using MSG_SHISEN_FIND_1WAY_PATH.
 *
 *              3. If a working path is found, store the corresponding points
 *                 in the history buffer for later drawing.
 *
 * RETURN:      Boolean – TRUE if a valid two-way path exists,
 *                        FALSE otherwise.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_FIND_2WAY_PATH
{
  Boolean ret = FALSE;

  /* try direct, straight one-segment path */
  if (@call self::MSG_SHISEN_FIND_1WAY_PATH(startX, startY, endX, endY))
  {
    pself->SBI_historyX[0] = startX;
    pself->SBI_historyY[0] = startY;
    pself->SBI_historyX[1] = endX;
    pself->SBI_historyY[1] = endY;
    ret = TRUE;
  }
  else
  {
    /* try L-shaped paths only when not aligned */
    if (!(startX == endX || startY == endY))
    {
      /* Option A: turn at (endX, startY) */
      if (pself->SBI_playField[endX][startY] == EMPTY &&
          @call self::MSG_SHISEN_FIND_1WAY_PATH(startX, startY, endX, startY) &&
          @call self::MSG_SHISEN_FIND_1WAY_PATH(endX, startY, endX, endY))
      {
        pself->SBI_historyX[0] = startX;
        pself->SBI_historyY[0] = startY;
        pself->SBI_historyX[1] = endX;
        pself->SBI_historyY[1] = startY;
        pself->SBI_historyX[2] = endX;
        pself->SBI_historyY[2] = endY;
        ret = TRUE;
      }
      else
      {
        /* Option B: turn at (startX, endY) */
        if (pself->SBI_playField[startX][endY] == EMPTY &&
            @call self::MSG_SHISEN_FIND_1WAY_PATH(startX, startY, startX, endY) &&
            @call self::MSG_SHISEN_FIND_1WAY_PATH(startX, endY, endX, endY))
        {
          pself->SBI_historyX[0] = startX;
          pself->SBI_historyY[0] = startY;
          pself->SBI_historyX[1] = startX;
          pself->SBI_historyY[1] = endY;
          pself->SBI_historyX[2] = endX;
          pself->SBI_historyY[2] = endY;
          ret = TRUE;
        }
      }
    }
  }
  return ret;
}

/***********************************************************************
 *              MSG_SHISEN_FIND_1WAY_PATH for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Determines whether a straight, unobstructed path exists
 *              between two tiles.  
 *              A valid one-way path is either purely horizontal or purely
 *              vertical, and all cells between the two positions must
 *              be EMPTY.
 *  
 * PARAMETERS:  int startX  – X-coordinate of the start tile
 *              int startY  – Y-coordinate of the start tile
 *              int endX    – X-coordinate of the end tile
 *              int endY    – Y-coordinate of the end tile
 *
 * STRATEGY:
 *              1. If tiles lie in the same column, scan vertically between
 *                 them for obstacles.
 *              2. If tiles lie in the same row, scan horizontally.
 *              3. Return TRUE only if all intermediate cells are EMPTY.
 *
 * RETURN:      Boolean – TRUE if a direct straight path exists,
 *                        FALSE otherwise.
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_FIND_1WAY_PATH
{
  int i;

  /* vertical alignment */
  if (startX == endX)
  {
    for (i = MIN(startY, endY) + 1; i < MAX(startY, endY); i++)
    {
      if (pself->SBI_playField[startX][i] != EMPTY)
        return FALSE;
    }
    return TRUE;
  }

  /* horizontal alignment */
  if (startY == endY)
  {
    for (i = MIN(startX, endX) + 1; i < MAX(startX, endX); i++)
    {
      if (pself->SBI_playField[i][startY] != EMPTY)
        return FALSE;
    }
    return TRUE;
  }

  /* not aligned — no straight path exists */
  return FALSE;
}


/***********************************************************************
 *              MSG_SHISEN_GAME_END for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Determines whether the game is finished by counting the
 *              number of remaining tiles on the board.  
 *              A return value of 0 indicates that all tiles have been
 *              successfully removed and the game is complete.
 *  
 * PARAMETERS:  void
 *
 * STRATEGY:
 *              Iterate through the entire playfield and count all cells
 *              that are not EMPTY.  
 *              The resulting number indicates how many tiles remain.
 *
 * RETURN:      word – number of tiles left on the board  
 *                     (0 means the game is finished)
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_GAME_END
{
  int  x, y;
  word numTiles = 0;

  for (x = 1; x <= pself->SBI_fieldWidth; x++)
  {
    for (y = 1; y <= pself->SBI_fieldHeight; y++)
    {
      if (pself->SBI_playField[x][y] != EMPTY)
        numTiles++;
    }
  }

  return numTiles;
}


/***********************************************************************
 *              MSG_SHISEN_UPDATE_BOARD for ShisenBoardClass
 ***********************************************************************
 * SYNOPSIS:    Clears the selection and history, redraws the playfield,
 *              removes previously selected tiles if a valid match was
 *              made, and checks whether the game is finished or if
 *              further moves are possible.
 *  
 * PARAMETERS:  void
 *
 * STRATEGY:
 *              1. Delete previously matched tiles using the history buffer.
 *              2. Clear selection and history.
 *              3. Redraw the board.
 *              4. Check if the game is finished (no tiles left).
 *              5. If not finished, check if any valid moves remain.
 *                 Display a warning dialog if no moves are possible.
 *
 * RETURN:      void
 *
 * REVISION HISTORY:
 *      Name    Date            Description
 *      ----    ----            -----------
 *      JK      08.08.00        Initial Revision
 *      JK      14.11.25        clean up
 *
 ***********************************************************************/
@method ShisenBoardClass, MSG_SHISEN_UPDATE_BOARD
{
  int x1, y1, x2, y2;

  /* delete selected tiles when needed */
  if(pself->SBI_historyX[0] && pself->SBI_historyY[0])
  {
    @call self::MSG_SHISEN_GET_SELECTION(&x1, &y1, &x2, &y2);

    pself->SBI_playField[x1][y1] = EMPTY;
    pself->SBI_playField[x2][y2] = EMPTY;
  }

  /* clear selection and history and redraw playfield */
  @call self::MSG_SHISEN_SET_SELECTION(0, 0, 0, 0);
  @call self::MSG_SHISEN_CLEAR_HISTORY();
  @call self::MSG_VIS_REDRAW_ENTIRE_OBJECT();

  /* if game finished? */
  if(@call self::MSG_SHISEN_GAME_END() == 0)
  {
    MemLock(OptrToHandle(@BoardCleared));
    UserStandardDialog(NULL, NULL, NULL, NULL,
                       LMemDeref(@BoardCleared),
                       (CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
			                 (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
    MemUnlock(OptrToHandle(@BoardCleared));
  }
  else
  {
    /* look for an allowed move */
    @call self::MSG_SHISEN_GET_MOVE(&x1, &y1, &x2, &y2);
    if(!(x1 || y1 || x2 || y2))
    {
      MemLock(OptrToHandle(@NoMovesLeft));
      UserStandardDialog(NULL, NULL, NULL, NULL,
                         LMemDeref(@NoMovesLeft),
                         (CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
			                   (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
	    MemUnlock(OptrToHandle(@NoMovesLeft));
    }
  }
}

